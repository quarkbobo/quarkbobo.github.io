<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>å¹ç‰›éª° Â· Liar's Diceï¼ˆå•äºº vs 2-4 äººæœºï¼‰</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --panel2:#0f1730;
      --text:#e7ecff;
      --muted:#a9b2d6;
      --accent:#6ea8ff;
      --good:#3ddc97;
      --bad:#ff5c7a;
      --warn:#ffd166;
      --chip:#1b2752;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC", "Microsoft YaHei", Arial;
      background: radial-gradient(1200px 600px at 20% 0%, #18265d 0%, var(--bg) 55%),
                  radial-gradient(900px 500px at 90% 40%, #21357a 0%, var(--bg) 60%);
      color:var(--text);
      min-height:100vh;
    }
    a{color:var(--accent)}

    header{
      padding: 22px 18px;
      position:sticky; top:0; z-index: 10;
      background: linear-gradient(180deg, rgba(11,16,32,.95) 0%, rgba(11,16,32,.55) 70%, rgba(11,16,32,0) 100%);
      backdrop-filter: blur(6px);
    }
    .wrap{max-width: 1120px; margin: 0 auto; padding: 0 12px 32px;}
    .titleRow{display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    h1{margin:0; font-size: 20px; letter-spacing:.2px;}
    .sub{margin:6px 0 0; color: var(--muted); font-size: 13px;}

    .grid{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap: 14px;
      margin-top: 10px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr;}
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06) 0%, rgba(255,255,255,.03) 100%);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHeader{
      padding: 14px 14px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.05) 0%, rgba(255,255,255,.02) 100%);
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .cardHeader h2{margin:0; font-size: 14px; letter-spacing:.3px;}
    .cardHeader .hint{color:var(--muted); font-size: 12px;}

    .cardBody{padding: 14px;}

    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .row + .row{margin-top:10px;}

    .btn{
      appearance:none; border:none; cursor:pointer;
      padding: 10px 12px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(110,168,255,.22) 0%, rgba(110,168,255,.14) 100%);
      color: var(--text);
      border: 1px solid rgba(110,168,255,.35);
      transition: transform .08s ease, filter .18s ease;
      font-weight: 650;
      letter-spacing:.2px;
    }
    .btn:hover{filter: brightness(1.08)}
    .btn:active{transform: translateY(1px) scale(.99)}
    .btn.secondary{
      background: linear-gradient(180deg, rgba(255,255,255,.10) 0%, rgba(255,255,255,.06) 100%);
      border-color: rgba(255,255,255,.16);
      font-weight: 600;
    }
    .btn.danger{
      background: linear-gradient(180deg, rgba(255,92,122,.28) 0%, rgba(255,92,122,.14) 100%);
      border-color: rgba(255,92,122,.45);
    }
    .btn.good{
      background: linear-gradient(180deg, rgba(61,220,151,.25) 0%, rgba(61,220,151,.12) 100%);
      border-color: rgba(61,220,151,.40);
    }
    .btn:disabled{
      opacity:.45; cursor:not-allowed;
      filter: grayscale(.2);
    }

    .select, .input{
      background: rgba(15,23,48,.75);
      border: 1px solid rgba(255,255,255,.14);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      outline: none;
      min-width: 120px;
    }
    .input{min-width: 92px; width: 110px;}
    .select:focus, .input:focus{border-color: rgba(110,168,255,.55); box-shadow: 0 0 0 3px rgba(110,168,255,.18)}

    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--muted);
      font-size: 12px;
    }

    .chips{display:flex; gap:8px; flex-wrap:wrap;}
    .chip{
      background: rgba(27,39,82,.75);
      border: 1px solid rgba(255,255,255,.12);
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
    }
    .chip strong{color: var(--text)}

    .players{
      display:grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    @media (max-width: 560px){
      .players{grid-template-columns: 1fr;}
    }
    .pCard{
      background: rgba(15,23,48,.6);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding: 12px;
      position: relative;
    }
    .pTop{display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .pName{font-weight:750}
    .pMeta{color:var(--muted); font-size:12px}
    .diceRow{display:flex; gap:8px; margin-top:10px; flex-wrap:wrap;}

    .die{
      width: 40px; height: 40px;
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.16) 0%, rgba(255,255,255,.08) 100%);
      border: 1px solid rgba(255,255,255,.16);
      display:flex; align-items:center; justify-content:center;
      font-size: 18px; font-weight: 850;
      box-shadow: 0 10px 16px rgba(0,0,0,.25);
      user-select:none;
    }
    .die.wild{outline: 2px solid rgba(255,209,102,.55);}

    .die.rolling{animation: roll .65s ease-in-out infinite;}
    @keyframes roll{
      0%{transform: rotate(0deg) translateY(0)}
      35%{transform: rotate(8deg) translateY(-2px)}
      70%{transform: rotate(-10deg) translateY(1px)}
      100%{transform: rotate(0deg) translateY(0)}
    }

    .log{
      height: 320px;
      overflow:auto;
      padding: 12px;
      background: rgba(15,23,48,.55);
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
    }
    .logItem{padding: 8px 10px; border-radius: 14px; margin: 8px 0; border:1px solid rgba(255,255,255,.10); background: rgba(255,255,255,.04)}
    .logItem .t{font-size: 12px; color: var(--muted); margin-bottom:4px}
    .logItem.good{border-color: rgba(61,220,151,.35); background: rgba(61,220,151,.08)}
    .logItem.bad{border-color: rgba(255,92,122,.35); background: rgba(255,92,122,.08)}
    .logItem.warn{border-color: rgba(255,209,102,.35); background: rgba(255,209,102,.08)}

    details{border-radius: 16px; border: 1px solid rgba(255,255,255,.12); background: rgba(15,23,48,.50); overflow:hidden}
    summary{cursor:pointer; padding: 12px 14px; font-weight: 750;}
    details .ruleBody{padding: 0 14px 14px; color: var(--muted); font-size: 13px; line-height: 1.6}
    .ruleBody b{color: var(--text)}

    .toast{
      position:fixed; bottom:16px; left:50%; transform:translateX(-50%);
      background: rgba(15,23,48,.92);
      border: 1px solid rgba(255,255,255,.12);
      padding: 10px 12px;
      border-radius: 999px;
      color: var(--text);
      box-shadow: var(--shadow);
      display:none;
      z-index: 50;
      max-width: 92vw;
      font-size: 13px;
    }

    .small{font-size:12px; color: var(--muted)}
    .kpi{display:flex; gap:10px; flex-wrap:wrap}
    .kpi .badge{background: rgba(110,168,255,.12); border-color: rgba(110,168,255,.25); color: var(--text)}

    .footerNote{margin-top: 12px; color: var(--muted); font-size: 12px; line-height: 1.5}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="titleRow">
        <div>
          <h1>å¹ç‰›éª° Â· Liar's Dice</h1>
          <div class="sub">å•äººç©å®¶ vs 2â€“4 äººæœº Â· 5 é¢—éª°å­/äºº Â· 1 ä¸ºä¸‡èƒ½ç‚¹ï¼ˆå¯åˆ‡æ¢ï¼‰</div>
        </div>
        <div class="kpi">
          <span class="badge" id="kpiRound">å›åˆï¼š-</span>
          <span class="badge" id="kpiTurn">è¡ŒåŠ¨ï¼š-</span>
          <span class="badge" id="kpiBid">å½“å‰å–Šæ³¨ï¼š-</span>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <div class="grid">
      <!-- å·¦ï¼šæ§åˆ¶ä¸è§„åˆ™ -->
      <section class="card" aria-label="æ§åˆ¶é¢æ¿">
        <div class="cardHeader">
          <h2>æ§åˆ¶é¢æ¿</h2>
          <div class="hint">å…ˆå¼€å±€ï¼Œå†å–Šæ³¨æˆ–æŠ“</div>
        </div>
        <div class="cardBody">
          <div class="row">
            <label class="small">äººæœºæ•°é‡</label>
            <select class="select" id="aiCount">
              <option value="2">2</option>
              <option value="3" selected>3</option>
              <option value="4">4</option>
            </select>
            <label class="small">æ¯äººéª°å­</label>
            <select class="select" id="dicePerPlayer">
              <option value="5" selected>5</option>
              <option value="4">4</option>
              <option value="3">3</option>
            </select>
          </div>

          <div class="row">
            <label class="small">è§„åˆ™ï¼š1 ä¸ºä¸‡èƒ½</label>
            <select class="select" id="wildRule">
              <option value="on" selected>å¼€å¯ï¼ˆé…’å§å¸¸è§ï¼‰</option>
              <option value="off">å…³é—­ï¼ˆæ›´ç¡¬æ ¸ï¼‰</option>
            </select>
            <label class="small">æ·˜æ±°ï¼šè¾“ä¸€é¢—</label>
            <select class="select" id="loseDieRule">
              <option value="on" selected>å¼€å¯</option>
              <option value="off">å…³é—­ï¼ˆåªè®¡åˆ†ä¸æ·˜æ±°ï¼‰</option>
            </select>
          </div>

          <div class="row" style="margin-top:12px">
            <button class="btn good" id="btnNew">æ–°æ¸¸æˆ</button>
            <button class="btn secondary" id="btnNextRound" disabled>å¼€å§‹/ä¸‹ä¸€è½®ï¼ˆæ‘‡éª°ï¼‰</button>
            <button class="btn secondary" id="btnShowAll" disabled>å¼€ç›…æŸ¥çœ‹ï¼ˆè°ƒè¯•ï¼‰</button>
          </div>

          <div style="height:10px"></div>

          <div class="card" style="background: rgba(15,23,48,.40); border-color: rgba(255,255,255,.10)">
            <div class="cardHeader">
              <h2>ä½ çš„æ“ä½œ</h2>
              <div class="hint">è½®åˆ°ä½ æ—¶å¯ç”¨</div>
            </div>
            <div class="cardBody">
              <div class="row">
                <label class="small">å–Šæ³¨ï¼šæ•°é‡</label>
                <input class="input" type="number" min="1" step="1" id="bidQty" value="1" />
                <label class="small">ç‚¹æ•°</label>
                <select class="select" id="bidFace">
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                  <option value="6" selected>6</option>
                  <option value="1">1ï¼ˆæŠ¥ 1 æ—¶ä¸ä¸‡èƒ½ï¼‰</option>
                </select>
              </div>
              <div class="row">
                <button class="btn" id="btnBid" disabled>å–Šæ³¨</button>
                <button class="btn danger" id="btnCall" disabled>æŠ“ï¼ˆè´¨ç–‘ï¼‰</button>
              </div>
              <div class="footerNote">
                å°æç¤ºï¼š
                <ul style="margin:6px 0 0 18px; padding:0">
                  <li>æ•°é‡å¿…é¡»æ¯”ä¸Šä¸€æ‰‹æ›´å¤§ï¼Œæˆ–æ•°é‡ç›¸åŒä½†ç‚¹æ•°æ›´å¤§ã€‚</li>
                  <li>å½“ <b>1 ä¸ºä¸‡èƒ½</b> æ—¶ï¼Œå–Šã€ŒXä¸ªY(é1)ã€ä¼šæŠŠæ‰€æœ‰ 1 ä¹Ÿç®—ä½œ Yã€‚</li>
                  <li>å–Šã€ŒXä¸ª1ã€æ—¶ï¼Œåªæœ‰ 1 ç®— 1ï¼Œä¸ä¸‡èƒ½ã€‚</li>
                </ul>
              </div>
            </div>
          </div>

          <div style="height:12px"></div>

          <details>
            <summary>ğŸ“œ è¯¦ç»†è§„åˆ™ï¼ˆå»ºè®®å±•å¼€é˜…è¯»ï¼‰</summary>
            <div class="ruleBody">
              <p><b>ç›®æ ‡ï¼š</b>é€šè¿‡åˆç†å–Šæ³¨ã€åˆ¤æ–­å¯¹æ‰‹æ˜¯å¦å¹ç‰›ï¼Œåœ¨å¯¹å±€ä¸­å­˜æ´»åˆ°æœ€åã€‚</p>
              <p><b>å¼€å±€ï¼š</b>æ¯äººè·å¾— N é¢—éª°å­ï¼ˆé»˜è®¤ 5ï¼‰ã€‚æ¯è½®æ‰€æœ‰äººåŒæ—¶æ‘‡éª°å¹¶æ‰£åœ¨æ¡Œé¢ï¼Œæ¯äººåªçœ‹è‡ªå·±ã€‚</p>
              <p><b>å–Šæ³¨æ ¼å¼ï¼š</b>ã€ŒX ä¸ª Yã€ï¼Œè¡¨ç¤ºï¼šå…¨åœºæ‰€æœ‰éª°å­é‡Œï¼Œè‡³å°‘æœ‰ X é¢—æ˜¯ Yã€‚</p>
              <p><b>1 ä¸ºä¸‡èƒ½ï¼ˆå¯åˆ‡æ¢ï¼‰ï¼š</b>å½“è§„åˆ™å¼€å¯æ—¶ï¼Œå–Šã€ŒX ä¸ª Yï¼ˆYâ‰ 1ï¼‰ã€æ—¶ï¼Œ<b>Yç‚¹ + 1ç‚¹</b> å…±åŒè®¡æ•°ï¼›å–Šã€ŒX ä¸ª 1ã€æ—¶åªæœ‰ 1 ç‚¹è®¡æ•°ã€‚</p>
              <p><b>è¡ŒåŠ¨ï¼š</b>è½®åˆ°ä½ æ—¶ï¼Œä½ å¯ä»¥ï¼š
                <br>â‘  <b>åŠ æ³¨</b>ï¼šæŠ¥ä¸€ä¸ªæ›´å¤§çš„æ³¨ï¼ˆæ•°é‡æ›´å¤§ï¼Œæˆ–æ•°é‡ç›¸åŒç‚¹æ•°æ›´å¤§ï¼‰ã€‚
                <br>â‘¡ <b>æŠ“</b>ï¼šè´¨ç–‘ä¸Šä¸€ä½ç©å®¶çš„æ³¨ä¸æˆç«‹ï¼Œè¦æ±‚å¼€ç›…ã€‚</p>
              <p><b>å¼€ç›…åˆ¤å®šï¼š</b>è‹¥æ¡Œé¢æ»¡è¶³ä¸Šä¸€æ‰‹å–Šæ³¨ â†’ æŠ“çš„äººè¾“ï¼›å¦åˆ™è¢«æŠ“çš„äººè¾“ã€‚</p>
              <p><b>è¾“çš„æƒ©ç½šï¼š</b>è‹¥å¼€å¯ã€Œè¾“ä¸€é¢—ã€è§„åˆ™ï¼Œè¾“çš„äººæœ¬å±€å‡å°‘ä¸€é¢—éª°å­ï¼›éª°å­ä¸º 0 åˆ™æ·˜æ±°ã€‚å…³é—­åˆ™åªæ˜¾ç¤ºè¾“èµ¢ï¼Œä¸æ·˜æ±°ã€‚</p>
              <p><b>ç†æ€§äººæœºï¼š</b>äººæœºä¼šæ ¹æ®ï¼š
                <br>â€¢ è‡ªå·±éª°å­ä¸­æŸç‚¹å‡ºç°çš„æ¦‚ç‡
                <br>â€¢ å½“å‰å–Šæ³¨åœ¨å…¨å±€æˆç«‹çš„æ¦‚ç‡ï¼ˆè´å¶æ–¯/äºŒé¡¹è¿‘ä¼¼ï¼‰
                <br>â€¢ ä½ æ˜¯å¦ç»å¸¸æŠ“/ç»å¸¸åŠ æ³¨ï¼ˆé£æ ¼å­¦ä¹ ï¼‰
                <br>æ¥å†³å®šæ˜¯è·Ÿæ³¨è¿˜æ˜¯æŠ“ã€‚</p>
            </div>
          </details>
        </div>
      </section>

      <!-- å³ï¼šç©å®¶æ¡Œé¢ä¸æ—¥å¿— -->
      <section class="card" aria-label="æ¡Œé¢">
        <div class="cardHeader">
          <h2>æ¡Œé¢</h2>
          <div class="hint" id="tableHint">ç‚¹å‡»â€œæ–°æ¸¸æˆâ€å¼€å§‹</div>
        </div>
        <div class="cardBody">
          <div class="players" id="players"></div>

          <div style="height:12px"></div>

          <div class="card" style="background: rgba(15,23,48,.38); border-color: rgba(255,255,255,.10)">
            <div class="cardHeader">
              <h2>å¯¹å±€æ—¥å¿—</h2>
              <div class="hint">ä¼šè®°å½•æ¯æ¬¡å–Šæ³¨/æŠ“/å¼€ç›…</div>
            </div>
            <div class="cardBody">
              <div class="log" id="log"></div>
              <div class="row" style="margin-top:10px">
                <button class="btn secondary" id="btnClearLog">æ¸…ç©ºæ—¥å¿—</button>
                <span class="small">ï¼ˆä¸ä¼šå½±å“æ¸¸æˆï¼‰</span>
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </main>

  <div class="toast" id="toast"></div>

<script>
(() => {
  // -----------------------------
  // Utilities
  // -----------------------------
  const $ = (sel) => document.querySelector(sel);
  const el = (tag, cls) => { const n=document.createElement(tag); if(cls) n.className=cls; return n; };
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
  const nowTime = () => new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});

  function toast(msg){
    const t = $('#toast');
    t.textContent = msg;
    t.style.display = 'block';
    clearTimeout(toast._tm);
    toast._tm = setTimeout(() => t.style.display='none', 1800);
  }

  function log(msg, kind=''){
    const box = $('#log');
    const item = el('div', 'logItem' + (kind ? ' '+kind : ''));
    const tt = el('div','t');
    tt.textContent = nowTime();
    const body = el('div');
    body.innerHTML = msg;
    item.appendChild(tt);
    item.appendChild(body);
    box.appendChild(item);
    box.scrollTop = box.scrollHeight;
  }

  // -----------------------------
  // Game State
  // -----------------------------
  const state = {
    players: [],
    aiCount: 3,
    dicePerPlayer: 5,
    wild: true,
    loseDie: true,

    round: 0,
    turnIndex: 0,
    bid: null, // {qty, face, by}
    phase: 'idle', // idle | rolling | bidding | reveal | over

    // player modeling (human behavior)
    humanProfile: {
      calls: 0,
      bids: 0,
      aggressiveScore: 0, // + when makes big jumps
      recent: [] // last 8 actions
    }
  };

  function makePlayer(name, isHuman=false, id=''){
    return {
      id: id || name,
      name,
      isHuman,
      dice: [],
      diceCount: state.dicePerPlayer,
      alive: true,
      // AI personality
      boldness: isHuman ? 0 : (0.35 + Math.random()*0.4),
      honesty: isHuman ? 0 : (0.45 + Math.random()*0.35),
      memory: {
        // track opponent patterns
        seenCalls: 0,
        seenBids: 0
      }
    };
  }

  function totalDiceAlive(){
    return state.players.filter(p=>p.alive).reduce((s,p)=>s+p.diceCount,0);
  }

  function currentPlayer(){
    return state.players[state.turnIndex];
  }

  function nextAliveIndex(from){
    const n = state.players.length;
    let i = from;
    for(let k=0;k<n;k++){
      i = (i+1)%n;
      if(state.players[i].alive) return i;
    }
    return from;
  }

  function alivePlayers(){
    return state.players.filter(p=>p.alive);
  }

  function winnerIfAny(){
    const alive = alivePlayers();
    if(alive.length===1) return alive[0];
    return null;
  }

  // -----------------------------
  // Dice & probability helpers
  // -----------------------------
  function rollDiceForAll(){
    for(const p of state.players){
      if(!p.alive) continue;
      p.dice = [];
      for(let i=0;i<p.diceCount;i++) p.dice.push(randInt(1,6));
    }
  }

  function countMatching(dice, face, wild){
    if(face===1) return dice.filter(x=>x===1).length;
    if(!wild) return dice.filter(x=>x===face).length;
    return dice.filter(x=>x===face || x===1).length;
  }

  // Binomial tail probability P(X >= k) for X~Bin(n,p)
  function binomTail(n, p, k){
    // small n only (<= 25-ish). We'll compute exact sum with stable multiplication.
    if(k<=0) return 1;
    if(k>n) return 0;
    let prob = 0;
    // compute pmf iteratively
    // start at x=0
    let pmf = Math.pow(1-p, n);
    if(0>=k) prob += pmf;
    for(let x=1; x<=n; x++){
      pmf = pmf * ((n - x + 1) / x) * (p/(1-p));
      if(x>=k) prob += pmf;
    }
    return clamp(prob,0,1);
  }

  function pFace(wild, face){
    // probability a random unknown die counts as target for this bid
    if(face===1) return 1/6;
    return wild ? 2/6 : 1/6;
  }

  function bidProbabilityGivenMyDice(player, bid){
    // estimate P(bid true) from player's perspective
    const alive = alivePlayers();
    const total = totalDiceAlive();
    const mine = player.diceCount;
    const unknown = total - mine;
    const have = countMatching(player.dice, bid.face, state.wild);
    const need = bid.qty - have;
    if(need<=0) return 1;
    const p = pFace(state.wild, bid.face);
    return binomTail(unknown, p, need);
  }

  function bidLegality(newBid){
    // return {ok, reason}
    if(!newBid || !Number.isFinite(newBid.qty) || !Number.isFinite(newBid.face)) return {ok:false, reason:'æ— æ•ˆå–Šæ³¨'};
    if(newBid.qty<1) return {ok:false, reason:'æ•°é‡è‡³å°‘ä¸º 1'};
    if(newBid.face<1||newBid.face>6) return {ok:false, reason:'ç‚¹æ•°èŒƒå›´ 1-6'};
    if(state.bid==null) return {ok:true, reason:''};
    const b = state.bid;
    const bigger = (newBid.qty > b.qty) || (newBid.qty === b.qty && newBid.face > b.face);
    if(!bigger) return {ok:false, reason:'å¿…é¡»æ¯”ä¸Šä¸€æ‰‹æ›´å¤§ï¼ˆæ•°é‡æ›´å¤§ï¼Œæˆ–æ•°é‡ç›¸åŒç‚¹æ•°æ›´å¤§ï¼‰'};
    return {ok:true, reason:''};
  }

  // -----------------------------
  // Rendering
  // -----------------------------
  function renderPlayers(){
    const box = $('#players');
    box.innerHTML = '';
    for(const p of state.players){
      const pc = el('div','pCard');
      if(!p.alive) pc.style.opacity = .45;

      const top = el('div','pTop');
      const left = el('div');
      const nm = el('div','pName'); nm.textContent = p.name + (p.isHuman ? 'ï¼ˆä½ ï¼‰' : '');
      const meta = el('div','pMeta');
      meta.textContent = p.alive ? `éª°å­ï¼š${p.diceCount}` : `å·²æ·˜æ±°`;
      left.appendChild(nm); left.appendChild(meta);

      const right = el('div','chips');
      if(p.isHuman){
        right.appendChild(chip(`ä½ çš„ç‚¹æ•°å¯è§`, true));
      } else {
        right.appendChild(chip(`äººæœº`, true));
      }

      top.appendChild(left); top.appendChild(right);
      pc.appendChild(top);

      const diceRow = el('div','diceRow');
      // show human dice; AI dice as hidden
      for(let i=0;i<p.diceCount;i++){
        const d = el('div','die');
        const v = p.dice[i] ?? 0;
        if(p.isHuman || state.phase==='reveal' || $('#btnShowAll').dataset.reveal==='1'){
          d.textContent = v;
          if(state.wild && v===1) d.classList.add('wild');
        } else {
          d.textContent = 'â€¢';
        }
        diceRow.appendChild(d);
      }
      pc.appendChild(diceRow);

      // turn indicator
      if(p.alive && state.phase!=='idle'){
        const isTurn = (state.players[state.turnIndex]===p);
        if(isTurn){
          pc.style.outline = '2px solid rgba(110,168,255,.55)';
          pc.style.boxShadow = '0 0 0 6px rgba(110,168,255,.12), ' + getComputedStyle(document.documentElement).getPropertyValue('--shadow');
        }
      }

      box.appendChild(pc);
    }
  }

  function chip(text, solid=false){
    const c = el('span','chip');
    c.innerHTML = solid ? `<strong>${text}</strong>` : text;
    return c;
  }

  function renderKPI(){
    $('#kpiRound').textContent = `å›åˆï¼š${state.round || '-'}`;
    const cp = currentPlayer();
    $('#kpiTurn').textContent = `è¡ŒåŠ¨ï¼š${cp ? cp.name : '-'}${cp?.isHuman?'ï¼ˆä½ ï¼‰':''}`;
    $('#kpiBid').textContent = state.bid ? `å½“å‰å–Šæ³¨ï¼š${state.bid.qty} ä¸ª ${state.bid.face}` : 'å½“å‰å–Šæ³¨ï¼š-';
  }

  function setControls(){
    const cp = currentPlayer();
    const humanTurn = (cp && cp.isHuman);
    const inBidPhase = (state.phase==='bidding');

    $('#btnBid').disabled = !(humanTurn && inBidPhase);
    $('#btnCall').disabled = !(humanTurn && inBidPhase && state.bid!=null);
    $('#btnNextRound').disabled = (state.phase==='idle' || state.phase==='over') ? false : (state.phase==='rolling');

    // cannot start next round in middle of bidding
    if(state.phase==='bidding') $('#btnNextRound').disabled = true;
    if(state.phase==='reveal') $('#btnNextRound').disabled = false;

    // show all (debug)
    $('#btnShowAll').disabled = state.phase==='idle';

    // bid qty min
    const minQty = state.bid ? state.bid.qty : 1;
    $('#bidQty').min = minQty;
  }

  function setHint(text){
    $('#tableHint').textContent = text;
  }

  async function animateRoll(){
    state.phase = 'rolling';
    setHint('æ‘‡éª°ä¸­â€¦');
    renderKPI();
    setControls();

    // add rolling class
    document.querySelectorAll('.die').forEach(d=>d.classList.add('rolling'));
    // quick fake updates
    const t0 = performance.now();
    while(performance.now()-t0 < 900){
      // update visible dice
      for(const p of state.players){
        if(!p.alive) continue;
        for(let i=0;i<p.diceCount;i++){
          if(p.isHuman){ p.dice[i] = randInt(1,6); }
        }
      }
      renderPlayers();
      await new Promise(r=>setTimeout(r, 85));
    }

    // final roll
    rollDiceForAll();

    // remove rolling
    renderPlayers();
    document.querySelectorAll('.die').forEach(d=>d.classList.remove('rolling'));
  }

  // -----------------------------
  // Game Flow
  // -----------------------------
  function newGame(){
    state.aiCount = parseInt($('#aiCount').value,10);
    state.dicePerPlayer = parseInt($('#dicePerPlayer').value,10);
    state.wild = ($('#wildRule').value==='on');
    state.loseDie = ($('#loseDieRule').value==='on');

    state.players = [];
    state.players.push(makePlayer('ç©å®¶', true, 'human'));
    for(let i=1;i<=state.aiCount;i++){
      state.players.push(makePlayer('AI-'+i, false, 'ai'+i));
    }

    for(const p of state.players){
      p.diceCount = state.dicePerPlayer;
      p.alive = true;
      p.dice = [];
    }

    state.round = 0;
    state.turnIndex = 0;
    state.bid = null;
    state.phase = 'idle';

    state.humanProfile = {calls:0,bids:0,aggressiveScore:0,recent:[]};

    $('#btnShowAll').dataset.reveal = '0';
    $('#log').innerHTML = '';

    renderPlayers();
    renderKPI();
    setControls();
    setHint('å·²åˆ›å»ºæ–°æ¸¸æˆã€‚ç‚¹å‡»â€œå¼€å§‹/ä¸‹ä¸€è½®ï¼ˆæ‘‡éª°ï¼‰â€ã€‚');
    log(`ğŸ² æ–°æ¸¸æˆå¼€å§‹ï¼šä½  vs ${state.aiCount} äººæœºã€‚è§„åˆ™ï¼š1ä¸ºä¸‡èƒ½=${state.wild?'å¼€å¯':'å…³é—­'}ï¼Œè¾“ä¸€é¢—=${state.loseDie?'å¼€å¯':'å…³é—­'}ã€‚`, 'good');
  }

  async function startNextRound(){
    if(state.phase==='bidding') return;

    // clear previous bid
    state.bid = null;

    // advance round count
    state.round += 1;

    // choose starting player: rotate from last starter to keep fair
    if(state.round===1){
      state.turnIndex = 0;
    } else {
      state.turnIndex = nextAliveIndex(state.turnIndex); // simple rotate
    }

    await animateRoll();

    state.phase = 'bidding';
    setHint('å·²æ‘‡éª°ï¼šè½®åˆ°èµ·æ‰‹ç©å®¶å–Šæ³¨ã€‚');
    renderPlayers();
    renderKPI();
    setControls();

    log(`ğŸŸ¦ ç¬¬ ${state.round} å›åˆå¼€å§‹ã€‚${currentPlayer().name} å…ˆæ‰‹ã€‚`, 'warn');

    // if AI starts, let AI act
    await maybeAIAutoPlay();
  }

  async function maybeAIAutoPlay(){
    // allow chain of AI turns until human
    let guard = 0;
    while(state.phase==='bidding' && !currentPlayer().isHuman && guard++ < 40){
      await new Promise(r=>setTimeout(r, 350));
      const ai = currentPlayer();
      const action = aiChooseAction(ai);
      if(action.type==='call'){
        log(`ğŸ¤– <b>${ai.name}</b> é€‰æ‹© <b>æŠ“</b>ï¼šè´¨ç–‘ä¸Šä¸€æ‰‹ã€Œ${state.bid.qty}ä¸ª${state.bid.face}ã€ã€‚`);
        await revealAndResolve(ai, state.bid.by);
        break;
      } else {
        state.bid = {qty: action.bid.qty, face: action.bid.face, by: ai.id};
        log(`ğŸ¤– <b>${ai.name}</b> å–Šæ³¨ï¼š<b>${state.bid.qty} ä¸ª ${state.bid.face}</b>ã€‚`);
        state.turnIndex = nextAliveIndex(state.turnIndex);
        renderPlayers(); renderKPI(); setControls();
      }
    }

    if(state.phase==='bidding' && currentPlayer().isHuman){
      setHint('è½®åˆ°ä½ ï¼šå¯ä»¥åŠ æ³¨æˆ–æŠ“ã€‚');
      toast('è½®åˆ°ä½ äº†ï¼šå–Šæ³¨æˆ–æŠ“');
      renderKPI(); setControls();
    }
  }

  function updateHumanProfile(action, bidBefore, bidAfter){
    const hp = state.humanProfile;
    if(action==='call') hp.calls++;
    if(action==='bid') hp.bids++;

    // aggressive: jump in qty
    if(action==='bid' && bidBefore && bidAfter){
      const jump = bidAfter.qty - bidBefore.qty;
      if(jump>=2) hp.aggressiveScore += 1.0;
      if(jump===1) hp.aggressiveScore += 0.35;
      if(jump<=0) hp.aggressiveScore -= 0.15;
    }
    hp.recent.push({action, t:Date.now()});
    if(hp.recent.length>8) hp.recent.shift();
  }

  // -----------------------------
  // AI Decision (smart & rational)
  // -----------------------------
  function aiChooseAction(ai){
    // Evaluate current bid probability from ai perspective
    const b = state.bid;
    const total = totalDiceAlive();

    // Human style learning: more likely to bluff if aggressive
    const hp = state.humanProfile;
    const humanAgg = clamp(hp.aggressiveScore / Math.max(1, hp.bids), -1, 2);
    const humanCallRate = hp.calls / Math.max(1, hp.calls + hp.bids);

    // if no bid yet: open with a reasonable bid based on own dice
    if(!b){
      const best = aiSuggestBidFromHand(ai, null);
      return {type:'bid', bid: best};
    }

    const pTrue = bidProbabilityGivenMyDice(ai, b);

    // compute "call threshold" influenced by AI boldness/honesty and human style
    // more aggressive human => more calling
    // more frequent human calls => less bluffing? (AI expects human to call more)
    let callThreshold = 0.22 + (0.22*(1-ai.boldness)) + (0.12*ai.honesty);
    callThreshold += 0.10*humanAgg;          // aggressive human -> call more
    callThreshold += 0.06*humanCallRate;     // if human often calls, AI also respects calling

    callThreshold = clamp(callThreshold, 0.10, 0.55);

    // If bid is very likely true, prefer to raise
    // If very unlikely true, call
    if(pTrue < callThreshold){
      return {type:'call'};
    }

    // Otherwise, raise with a bid that remains plausible
    const nextBid = aiSuggestBidFromHand(ai, b);

    // Occasionally choose to call even if borderline (risk management)
    const risk = (0.12 + 0.22*(1-ai.honesty));
    if(pTrue < callThreshold + 0.08 && Math.random() < risk*0.35){
      return {type:'call'};
    }

    return {type:'bid', bid: nextBid};
  }

  function aiSuggestBidFromHand(ai, baseBid){
    // Build candidate bids and choose max expected value based on probability and "legal" constraints.
    // We'll create a small neighborhood of bids near baseBid.

    const total = totalDiceAlive();
    const faces = [2,3,4,5,6,1];

    // Determine minimum legal bid
    let minQty = 1, minFace = 2;
    if(baseBid){
      minQty = baseBid.qty;
      minFace = baseBid.face;
    }

    const candidates = [];

    function pushBid(qty, face){
      const bid = {qty, face};
      if(!bidLegality(bid).ok) return;
      const p = bidProbabilityGivenMyDice(ai, bid);
      // value: prefer higher bids but penalize too-low probability
      // boldness shifts risk tolerance
      const riskPenalty = Math.pow(1 - p, 1.2 + (1-ai.boldness)*0.8);
      const sizeReward = (qty*1.05) + (face===1 ? 0.12 : face/12);
      const score = sizeReward - (riskPenalty * (1.2 + (1-ai.boldness)*0.6));
      candidates.push({bid, p, score});
    }

    // Generate a band around current
    const startQty = baseBid ? baseBid.qty : 1;
    for(let dq=0; dq<=3; dq++){
      const q = startQty + dq;
      for(const f of faces){
        // only consider f >= base face if same qty
        pushBid(q, f);
      }
    }

    // If baseBid exists, also consider same qty higher faces
    if(baseBid){
      for(const f of faces){
        if(f>baseBid.face) pushBid(baseBid.qty, f);
      }
    }

    // If no candidates (rare), fallback
    if(!candidates.length){
      const fallback = baseBid ? {qty: baseBid.qty+1, face: 2} : {qty:1, face:6};
      return fallback;
    }

    // Choose best by score, but ensure probability not absurd
    candidates.sort((a,b)=>b.score-a.score);

    // filter by minimal probability based on honesty
    const minP = 0.12 + 0.22*ai.honesty; // honest AI requires higher p
    const filtered = candidates.filter(c => c.p >= minP);

    const pickFrom = filtered.length ? filtered : candidates;

    // Softmax-ish: pick among top 4 to avoid determinism
    const top = pickFrom.slice(0,4);
    const weights = top.map((c,i)=>Math.exp((c.score - top[0].score) * (2.0 - i*0.2)));
    const sum = weights.reduce((s,x)=>s+x,0);
    let r = Math.random()*sum;
    for(let i=0;i<top.length;i++){
      r -= weights[i];
      if(r<=0) return top[i].bid;
    }
    return top[0].bid;
  }

  // -----------------------------
  // Reveal & Resolve
  // -----------------------------
  function computeTableCounts(face){
    let count = 0;
    for(const p of state.players){
      if(!p.alive) continue;
      count += countMatching(p.dice, face, state.wild);
    }
    return count;
  }

  async function revealAndResolve(caller, targetBy){
    state.phase = 'reveal';
    setHint('å¼€ç›…ä¸­â€¦');
    renderPlayers(); renderKPI(); setControls();

    const bid = state.bid;
    const totalCount = computeTableCounts(bid.face);
    const success = (totalCount >= bid.qty);

    // show all dice
    $('#btnShowAll').dataset.reveal = '1';
    renderPlayers();

    const callerP = state.players.find(p=>p.id===caller.id);
    const bidderP = state.players.find(p=>p.id===targetBy);

    const msg = `ğŸ” å¼€ç›…ï¼šç‚¹æ•° <b>${bid.face}</b>ï¼ˆ${state.wild && bid.face!==1 ? 'å«1ä¸‡èƒ½' : 'ä¸å«ä¸‡èƒ½'}ï¼‰ä¸€å…±æ•°åˆ° <b>${totalCount}</b> é¢—ã€‚å–Šæ³¨ä¸º <b>${bid.qty} ä¸ª ${bid.face}</b>ã€‚`;
    log(msg, 'warn');

    let loser = null;
    if(success){
      // caller loses
      loser = callerP;
      log(`âœ… å–Šæ³¨æˆç«‹ï¼å› æ­¤ <b>${callerP.name}</b> æŠ“é”™äº†ï¼Œåˆ¤è´Ÿã€‚`, 'bad');
    } else {
      // bidder loses
      loser = bidderP;
      log(`âŒ å–Šæ³¨ä¸æˆç«‹ï¼å› æ­¤ <b>${bidderP.name}</b> å¹ç‰›å¤±è´¥ï¼Œåˆ¤è´Ÿã€‚`, 'bad');
    }

    // apply penalty
    if(state.loseDie){
      loser.diceCount = Math.max(0, loser.diceCount - 1);
      if(loser.diceCount===0){
        loser.alive = false;
        log(`ğŸ’€ <b>${loser.name}</b> éª°å­å½’é›¶ï¼Œå·²æ·˜æ±°ã€‚`, 'bad');
      } else {
        log(`ğŸ¥ƒ å¤„ç½šï¼š<b>${loser.name}</b> å°‘ä¸€é¢—éª°å­ï¼ˆå‰©ä½™ ${loser.diceCount}ï¼‰ã€‚`, 'warn');
      }
    } else {
      log(`ğŸ¥ƒ å¤„ç½šè§„åˆ™å…³é—­ï¼šæœ¬è½®ä»…åˆ¤è´Ÿä¸æ·˜æ±°ã€‚`, 'warn');
    }

    // check winner
    const w = winnerIfAny();
    if(w){
      state.phase = 'over';
      setHint(`æ¸¸æˆç»“æŸï¼š${w.name}${w.isHuman?'ï¼ˆä½ ï¼‰':''} è·èƒœï¼ç‚¹å‡»â€œæ–°æ¸¸æˆâ€å†æ¥ã€‚`);
      log(`ğŸ† <b>${w.name}</b> è·èƒœï¼`, 'good');
      renderPlayers(); renderKPI(); setControls();
      toast('æ¸¸æˆç»“æŸï¼');
      return;
    }

    // Next round starter: loser starts (common house rule), else caller/ bidder? We'll choose loser.
    state.turnIndex = state.players.indexOf(loser);

    // keep reveal shown briefly then hide for next round
    await new Promise(r=>setTimeout(r, 900));

    // prepare for next round
    state.bid = null;
    $('#btnShowAll').dataset.reveal = '0';
    setHint('æœ¬è½®ç»“æŸã€‚ç‚¹å‡»â€œå¼€å§‹/ä¸‹ä¸€è½®ï¼ˆæ‘‡éª°ï¼‰â€ã€‚');
    renderPlayers(); renderKPI(); setControls();
  }

  // -----------------------------
  // Human Actions
  // -----------------------------
  async function humanBid(){
    if(state.phase!=='bidding') return;
    const cp = currentPlayer();
    if(!cp.isHuman) return;

    const qty = parseInt($('#bidQty').value,10);
    const face = parseInt($('#bidFace').value,10);
    const newBid = {qty, face};

    const leg = bidLegality(newBid);
    if(!leg.ok){ toast(leg.reason); return; }

    const prev = state.bid;
    state.bid = {qty, face, by: cp.id};

    updateHumanProfile('bid', prev, state.bid);

    log(`ğŸ§ ä½ å–Šæ³¨ï¼š<b>${qty} ä¸ª ${face}</b>ã€‚`);

    state.turnIndex = nextAliveIndex(state.turnIndex);
    renderPlayers(); renderKPI(); setControls();

    await maybeAIAutoPlay();
  }

  async function humanCall(){
    if(state.phase!=='bidding') return;
    const cp = currentPlayer();
    if(!cp.isHuman) return;
    if(!state.bid){ toast('è¿˜æ²¡æœ‰äººå–Šæ³¨ï¼Œä¸èƒ½æŠ“'); return; }

    updateHumanProfile('call', state.bid, state.bid);

    log(`ğŸ§ ä½ é€‰æ‹© <b>æŠ“</b>ï¼šè´¨ç–‘ä¸Šä¸€æ‰‹ã€Œ${state.bid.qty}ä¸ª${state.bid.face}ã€ã€‚`);
    // caller is human, target is last bidder
    await revealAndResolve(cp, state.bid.by);
  }

  // -----------------------------
  // Debug show all
  // -----------------------------
  function toggleShowAll(){
    const v = $('#btnShowAll').dataset.reveal==='1' ? '0' : '1';
    $('#btnShowAll').dataset.reveal = v;
    renderPlayers();
    toast(v==='1' ? 'å·²æ˜¾ç¤ºæ‰€æœ‰éª°å­ï¼ˆè°ƒè¯•ï¼‰' : 'å·²éšè—AIéª°å­');
  }

  // -----------------------------
  // Wire up UI
  // -----------------------------
  $('#btnNew').addEventListener('click', newGame);
  $('#btnNextRound').addEventListener('click', startNextRound);
  $('#btnBid').addEventListener('click', humanBid);
  $('#btnCall').addEventListener('click', humanCall);
  $('#btnShowAll').addEventListener('click', toggleShowAll);
  $('#btnClearLog').addEventListener('click', ()=>{ $('#log').innerHTML=''; toast('æ—¥å¿—å·²æ¸…ç©º'); });

  // Enter key triggers bid
  $('#bidQty').addEventListener('keydown', (e)=>{ if(e.key==='Enter') humanBid(); });

  // Initialize
  renderPlayers();
  renderKPI();
  setControls();
  setHint('ç‚¹å‡»â€œæ–°æ¸¸æˆâ€å¼€å§‹ã€‚');

})();
</script>
</body>
</html>
